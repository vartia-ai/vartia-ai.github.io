[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Vartia.ai",
    "section": "",
    "text": "vartia\n  Book a Consult\n\n\n\n\n\n\n\n\nExplore the latest posts.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)\n\n\n\n\n\n\n\n\nDec 15, 2025\n\n\nBrian Williams\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/oobench1/index.html",
    "href": "posts/oobench1/index.html",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "",
    "text": "vartia\n  Book a Consult"
  },
  {
    "objectID": "posts/oobench1/index.html#classifying-vulnerabilities-the-easy-baseline-that-wasnt",
    "href": "posts/oobench1/index.html#classifying-vulnerabilities-the-easy-baseline-that-wasnt",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "Classifying Vulnerabilities: The Easy Baseline That Wasn’t",
    "text": "Classifying Vulnerabilities: The Easy Baseline That Wasn’t\nI began by running a simple baseline experiment: test whether state-of-the-art LLMs can correctly classify real security vulnerabilities.\nThe source data was the Common Vulnerabilities and Exposures (CVE) database. CVEs include natural-language descriptions, one or more Common Weakness Enumeration (CWE) labels, and often the code patch that fixed the issue.\nI downloaded roughly 20 years of CVE data from NIST and filtered for memory-safety-related CWEs. CVEs with available GitHub commits were converted into a dataset of vulnerable functions paired with their assigned weaknesses.\nThe result:\n\n~1300 CVEs\n79% had a single CWE label\n\nThe task given to the LLMs was intentionally simple:\n\nGiven the vulnerable code and its patch, return one or more CWEs that describe the weakness.\n\nIf the model returned any CWE listed in the CVE record, it was considered correct. Hierarchical matching was not allowed. This was meant to be a loose baseline, not a strict evaluation.\nI assumed modern LLMs would perform extremely well.\nThey did not.\nFrontier models returned a correct CWE less than 50% of the time."
  },
  {
    "objectID": "posts/oobench1/index.html#are-we-asking-the-wrong-question",
    "href": "posts/oobench1/index.html#are-we-asking-the-wrong-question",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "Are We Asking the Wrong Question?",
    "text": "Are We Asking the Wrong Question?\nThis failure raises a deeper question:\n\nAre top-down CWE taxonomies compatible with code-centric evaluation at all?\n\nAfter digging into the dataset, the answer became clear: the problem is not the models—it is the labels.\nCWEs are assigned manually through a community-driven process spanning decades. That process is valuable, but it struggles to produce consistent, fine-grained, code-level classifications.\nThis is not an argument that CWEs are incorrect or useless.\nIt is an argument that they are misaligned with the task of classifying vulnerabilities directly from code."
  },
  {
    "objectID": "posts/oobench1/index.html#look-at-your-data",
    "href": "posts/oobench1/index.html#look-at-your-data",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "Look at Your Data",
    "text": "Look at Your Data\nTo understand what was happening, I looked at the label distribution.\n\n\n\nHistogram of CVEs by CWE label\n\n\nThe dataset is extremely imbalanced. A small number of CWEs dominate the majority of examples.\nNext, I examined where the model was wrong.\n\n\n\nMisclassification matrix for CWE prediction\n\n\nThis matrix only includes error cases—situations where the model’s prediction did not match any of the CVE’s assigned CWEs. Each cell shows the count of misclassified CVEs, with the dataset label on the row and the model prediction on the column.\nThe errors are not random. They cluster.\nCWE-119 is both:\n\nthe most over-predicted label, and\nthe most under-predicted ground-truth label\n\nThis makes sense. CWE-119 (“Improper Restriction of Operations within the Bounds of a Memory Buffer”) is a parent of CWE-120, CWE-125, CWE-787, and a grandparent of others like CWE-121 and CWE-122.\nIt acts as a semantic catch-all."
  },
  {
    "objectID": "posts/oobench1/index.html#when-two-labels-are-both-correct",
    "href": "posts/oobench1/index.html#when-two-labels-are-both-correct",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "When Two Labels Are Both Correct",
    "text": "When Two Labels Are Both Correct\nConsider CWE-122 (Heap-based Buffer Overflow) and CWE-787 (Out-of-Bounds Write).\nFor CVE-2025-54949, the official label is CWE-122.\nThe LLM predicted CWE-787.\nThe code uses memcpy to copy data into a heap buffer without verifying that the buffer has sufficient space.\nBoth labels are correct.\n\nThe mechanism is an out-of-bounds write.\nThe consequence is a heap-based buffer overflow.\n\nThe CWE hierarchy forces a choice. The code does not."
  },
  {
    "objectID": "posts/oobench1/index.html#why-bottom-up-classification-matters",
    "href": "posts/oobench1/index.html#why-bottom-up-classification-matters",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "Why Bottom-Up Classification Matters",
    "text": "Why Bottom-Up Classification Matters\nThe goal was never to reproduce CWE assignments.\nThe goal was to classify vulnerabilities as they manifest in code.\nTop-down labeling forces models to guess which level of abstraction the human annotator chose. That information is often absent from the code itself.\nTo build a code-centric evaluation system, weakness categories must be derived bottom-up, from concrete failure modes observed in real code—not imposed from a predefined hierarchy."
  },
  {
    "objectID": "posts/oobench1/index.html#whats-next",
    "href": "posts/oobench1/index.html#whats-next",
    "title": "OOBench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++ (1 of 4)",
    "section": "What’s Next",
    "text": "What’s Next\nIn the next article, I’ll describe how I built a bottom-up taxonomy for memory safety vulnerabilities, derived directly from observed code patterns rather than inherited labels.\nThat taxonomy is the foundation of OOBench."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vartia.ai",
    "section": "",
    "text": "Machine Learning Engineering\n\n    \n      BLOG\n      BOOK A CONSULT"
  },
  {
    "objectID": "index.html#latest-articles",
    "href": "index.html#latest-articles",
    "title": "Vartia.ai",
    "section": "Latest Articles",
    "text": "Latest Articles"
  }
]