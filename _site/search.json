[
  {
    "objectID": "posts/oob_bench1/index.html#classifying-vulnerabilities-the-easy-baseline-that-wasnt",
    "href": "posts/oob_bench1/index.html#classifying-vulnerabilities-the-easy-baseline-that-wasnt",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "Classifying Vulnerabilities: The Easy Baseline That Wasn’t",
    "text": "Classifying Vulnerabilities: The Easy Baseline That Wasn’t\nI began by running a simple baseline experiment: test whether state-of-the-art LLMs can correctly classify real security vulnerabilities.\nThe source data was the Common Vulnerabilities and Exposures (CVE) database. CVEs include natural-language descriptions, one or more Common Weakness Enumeration (CWE) labels, and often the code patch that fixed the issue.\nI downloaded roughly 20 years of CVE data from NIST and filtered for memory-safety-related CWEs. CVEs with available GitHub commits were converted into a dataset of vulnerable functions paired with their assigned weaknesses.\nThe result:\n\n~1300 CVEs\n79% had a single CWE label\n\nThe task given to the LLMs was intentionally simple:\n\nGiven the vulnerable code and its patch, return one or more CWEs that describe the weakness.\n\nIf the model returned any CWE listed in the CVE record, it was considered correct. Hierarchical matching was not allowed. This was meant to be a loose baseline, not a strict evaluation.\nI assumed modern LLMs would perform extremely well.\nThey did not.\nFrontier models returned a correct CWE less than 50% of the time."
  },
  {
    "objectID": "posts/oob_bench1/index.html#are-we-asking-the-wrong-question",
    "href": "posts/oob_bench1/index.html#are-we-asking-the-wrong-question",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "Are We Asking the Wrong Question?",
    "text": "Are We Asking the Wrong Question?\nThis failure raises a deeper question:\n\nAre top-down CWE taxonomies compatible with code-centric evaluation at all?\n\nAfter digging into the dataset, the answer became clear: the problem is not the models—it is the labels.\nCWEs are assigned manually through a community-driven process spanning decades. That process is valuable, but it struggles to produce consistent, fine-grained, code-level classifications.\nThis is not an argument that CWEs are incorrect or useless.\nIt is an argument that they are misaligned with the task of classifying vulnerabilities directly from code."
  },
  {
    "objectID": "posts/oob_bench1/index.html#look-at-your-data",
    "href": "posts/oob_bench1/index.html#look-at-your-data",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "Look at Your Data",
    "text": "Look at Your Data\nTo understand what was happening, I looked at the label distribution.\n\n\n\nHistogram of CVEs by CWE label\n\n\nThe dataset is extremely imbalanced. A small number of CWEs dominate the majority of examples.\nNext, I examined where the model was wrong.\n\n\n\nConfusion matrix for CWE prediction\n\n\nThis confusion matrix is a comparison of the dataset label and the LLM predicted lable. Correct predictions are found on the diagnal. All of the non-diagnal cells show a count of that type of misprediction.\nThe errors are not random. They cluster.\nCWE-119 is both:\n\nthe most over-predicted label (predicted as 119 when not)\nthe most under-predicted label (predicted as not 119 when it was)\n\nThis makes sense. CWE-119 (“Improper Restriction of Operations within the Bounds of a Memory Buffer”) is a parent of CWE-120, CWE-125, CWE-787, and a grandparent of others like CWE-121 and CWE-122.\nIt acts as a semantic catch-all."
  },
  {
    "objectID": "posts/oob_bench1/index.html#when-two-labels-are-both-correct",
    "href": "posts/oob_bench1/index.html#when-two-labels-are-both-correct",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "When Two Labels Are Both Correct",
    "text": "When Two Labels Are Both Correct\nConsider CWE-122 (Heap-based Buffer Overflow) and CWE-787 (Out-of-Bounds Write).\nFor CVE-2025-54949, the official label is CWE-122. The LLM predicted CWE-787.\nThe code uses memcpy to copy data into a heap buffer without verifying that the buffer has sufficient space.\nBoth labels are correct.\n\nThe mechanism is an out-of-bounds write.\nThe consequence is a heap-based buffer overflow.\n\nThe CWE hierarchy forces a choice. The code does not."
  },
  {
    "objectID": "posts/oob_bench1/index.html#why-bottom-up-classification-matters",
    "href": "posts/oob_bench1/index.html#why-bottom-up-classification-matters",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "Why Bottom-Up Classification Matters",
    "text": "Why Bottom-Up Classification Matters\nThe goal was never to reproduce CWE assignments.\nThe goal was to classify vulnerabilities as they manifest in code.\nTop-down labeling forces models to guess which level of abstraction the human annotator chose. That information is often absent from the code itself.\nTo build a code-centric evaluation system, weakness categories must be derived bottom-up, from concrete failure modes observed in real code—not imposed from a predefined hierarchy."
  },
  {
    "objectID": "posts/oob_bench1/index.html#whats-next",
    "href": "posts/oob_bench1/index.html#whats-next",
    "title": "OOB Bench: A Bottom-Up Classification of Memory Safety Vulnerabilities in C and C++",
    "section": "What’s Next",
    "text": "What’s Next\nIn the next article, I’ll describe how I built a bottom-up taxonomy for memory safety vulnerabilities, derived directly from observed code patterns rather than inherited labels.\nThat taxonomy is the foundation of OOB Bench."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "&lt;iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-KWNP27BF\" height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"&gt;&lt;/iframe&gt;\n\nAbout this blog"
  },
  {
    "objectID": "index.html#latest-articles",
    "href": "index.html#latest-articles",
    "title": "Vartia.ai",
    "section": "Latest Articles",
    "text": "Latest Articles"
  },
  {
    "objectID": "book.html",
    "href": "book.html",
    "title": "Book a Consult",
    "section": "",
    "text": "Book a Consult\nSchedule time with Vartia.ai using the embed below."
  }
]